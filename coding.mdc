# Cursor Rules - 程式碼簡潔性規範

## 核心原則

### 單一職責
- 一個函式只處理一件事
- 分離 I/O、流程控制、分析邏輯
- 避免職責混雜（流程控制 + 錯誤處理 + 輸出 + 狀態管理）

### 抽象重複
- 封裝常見的「檢查 + 回傳錯誤」邏輯
- 共用相似的日誌、錯誤處理邏輯
- 分離 demo code 與 library code

## 錯誤處理

### 結構化結果
- 使用 dataclass/Enum 而非 (bool, str, int)
- 避免 startswith("SUCCESS") 等字串判斷
- 集中錯誤處理，減少散落的 if not ... return

### 避免重複
- 不要大量 if not ... return
- 避免重複的 try/except
- 統一錯誤訊息格式

## 輸出與日誌

### 使用 logging
- 替代過多的 print 語句
- 依情境設定等級 (info, error, debug)
- 避免每個分支都 print + 分隔線 + emoji

### 安全輸出
- 遮罩或截斷敏感資訊
- 不要直接 log 密碼、完整回應

## 可重用性

### 避免硬編碼
- 測試密碼、次數、路徑透過參數/CLI 傳入
- 不要寫死固定數值

### API 設計
- 避免 demo 式設計（步驟全列出）
- 抽象化重複邏輯，提高重用性

## 狀態管理

### 減少依賴
- 回傳結果而非修改 self.*
- 避免依賴物件屬性 (self.session_id 等)
- 減少狀態耦合

### 資源管理
- 使用 with context manager
- 統一管理網路請求 (session, timeout, verify, retry)

## 安全與維護

### 網路安全
- 統一管理網路請求設定
- 避免手動展開設定

### 程式碼品質
- 平衡安全性和簡潔性
- 保持可讀性和可維護性

## 目標

遵循這些規則：
1. 寫出更簡潔、可讀的程式碼
2. 提高可維護性和重用性
3. 減少重複程式碼和錯誤處理
4. 建立更好的程式架構
5. 提升安全性和健壯性

