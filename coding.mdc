---
alwaysApply: false
---
# Cursor Rules - Code Simplicity Standards

## Core Principles

### Single Responsibility
- One function handles only one thing
- Separate I/O, flow control, and analysis logic
- Avoid mixed responsibilities (flow control + error handling + output + state management)

### Abstract Repetition
- Encapsulate common "check + return error" logic
- Share similar logging and error handling logic
- Separate demo code from library code

## Error Handling

### Structured Results
- Use dataclass/Enum instead of (bool, str, int)
- Avoid string comparisons like startswith("SUCCESS")
- Centralize error handling, reduce scattered if not ... return

### Avoid Repetition
- Don't use excessive if not ... return
- Avoid repetitive try/except blocks
- Standardize error message format

## Output and Logging

### Use Logging
- Replace excessive print statements
- Set appropriate levels based on context (info, error, debug)
- Avoid print + separators + emoji in every branch

### Secure Output
- Mask or truncate sensitive information
- Don't directly log passwords or complete responses

## Reusability

### Avoid Hardcoding
- Pass test passwords, counts, paths through parameters/CLI
- Don't hardcode fixed values

### API Design
- Avoid demo-style design (listing all steps)
- Abstract repetitive logic to improve reusability

## State Management

### Reduce Dependencies
- Return results instead of modifying self.*
- Avoid depending on object properties (self.session_id, etc.)
- Reduce state coupling

### Resource Management
- Use with context managers
- Centralize network request management (session, timeout, verify, retry)

## Security and Maintenance

### Network Security
- Centralize network request settings
- Avoid manual configuration expansion

### Code Quality
- Balance security and simplicity
- Maintain readability and maintainability

## Production Readiness Rules

### Remove All Debug Logging
**Rule:** No debug logging in production code
- Remove all `logger.debug()` statements
- Remove `print()` statements (except CLI tools)
- Set `enable_debug_logging: False` in config
- Keep only `logger.info()`, `logger.warning()`, `logger.error()` for production

### Simplify State Management
**Rule:** Use one state object per file
- Single `FileState` enum per file
- One state manager class (`StateMachineService`)
- Remove `UnifiedStateManager` complexity
- Store only essential state: `file_path`, `current_state`, `last_updated`

### Remove Unnecessary Error Handling Complexity
**Rule:** Simple error handling only
- Maximum 1 try-catch per method
- No nested try-catch blocks
- Use simple error logging: `logger.error(f"Failed: {e}")`
- Remove complex error recovery mechanisms
- Fail fast, don't retry excessively

### Streamline Configuration
**Rule:** Minimal configuration
- Maximum 10 configuration parameters
- Use simple dict: `{'timeout': 30, 'max_files': 1000}`
- Remove environment variable complexity
- No configuration merging functions
- Single config object per component

### Eliminate Redundant Methods and Checks
**Rule:** One method per responsibility
- Remove duplicate validation methods
- One callback registration method per class
- Remove redundant health check methods
- Combine similar methods into single implementations

## Goals

Following these rules will:
1. Write more concise, readable code
2. Improve maintainability and reusability
3. Reduce duplicate code and error handling
4. Build better program architecture
5. Enhance security and robustness
6. Never use fallback data - display errors directly when they occur

## Overall Principle
Keep it simple, remove complexity, focus on core functionality only.